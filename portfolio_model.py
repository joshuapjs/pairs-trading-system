"""
This module contains the relevant functions to size the current positions that should be taken,
according to the alpha_model properly.
"""
import os
import copy
from data_connector import Pair
from tws_connection import ib, build_connection

ACCOUNT_NUMBER = "DU8322667" # TODO: Create a data file that has all constants
PORTFOLIO_VALUE = 1000000.
ASSETS_TRADED = 10

# Check if a connection exists already
if not ib.isConnected():
    build_connection()


class Portfolio:
    """
    This class is used to manage the current Portfolio.
    """

    def __init__(self):
        self.profile = ACCOUNT_NUMBER
        self.empty_slots = copy.copy(ASSETS_TRADED)
        # TODO: This should be changed if the portfolio construction process trading
        self.followed_signals = {}

    def analyze_signals(self, new_signals):
        """
        Receives new Signals generated by alpha_model and determines how they will be handled.
        :param new_signals: list of signals of type: (deviation, sign, pair, quote_a, quote_b)
                            deviation: means the potential return, as the divergence between two stocks.
                            sign: is the direction with respect to ticker_a and ticker_b.
                            pair: is the Pair-Class-Object.
                            quote_a and quote_b: the respective most recent quotes.
                            const and slope: Parameters of the relationship between the stocks
        :return: Execution update (Information for the Execution Model which transactions to do)
        """
        portfolio_adjustment = {}

        # Retrieve and sort the signals generated by the alpha model.
        signals = list(new_signals.values())
        signals.sort(key=lambda a: a[0], reverse=True)
        # Calculate the amounts of shares need for each trade as long as there are still slots open.
        # Slot is the wording for each budget that can be traded on a pair. The risk strategy is at this point
        # equal weighting.
        for signal in signals:
            # Calculation of the amount of shares for each stock.
            if self.empty_slots > 0:
                deviation, sign, pair, quote_a, quote_b, const, slope = signal
                # Formel zur Berechnung des Anteils von b.
                shares_b = (PORTFOLIO_VALUE / ASSETS_TRADED - const * quote_a) * (1 / (slope * quote_a + quote_b))
                shares_a = const + slope * shares_b
                # Preparation of the output.
                ticker_a, ticker_b = pair
                portfolio_adjustment[ticker_a] = int(shares_a)
                portfolio_adjustment[ticker_b] = int(shares_b)
                self.empty_slots -= 1
            else:
                break

        return portfolio_adjustment

    def optimize(self):
        # This is at this stage only printing out the last trades.
        current_positions = ib.positions(self.profile)
        current_trades = ib.trades()
        for trade in current_trades:
            if len(trade.fills) > 1:
                for fill in trade.fills:
                    print(trade.contract.symbol, trade.order.action, fill.execution.price, fill.execution.shares)
            elif len(trade.fills) == 1:
                print(trade.contract.symbol, trade.order.action,  trade.fills[0].execution.price, trade.fills[0].execution.shares)
            else:
                print(trade.contract.symbol, trade.order.action,  " --No Fill--")


if __name__ == "__main__":
    signal_1 = (0.005, 1, None, (200., 190.))
    signal_2 = (0.01, -1, None, (270., 300.))
    signal_3 = (0.01, 1, None, (110., 100.))
    signal_4 = (0.02, 1, None, (300., 270.))

    test_data = {
        ("AAPL", "MSFT"): signal_1,
        ("CPNG", "AMZN"): signal_2,
        ("TSLA", "VW"): signal_3,
        ("GM", "NVDA"): signal_4
    }

    portfolio = Portfolio()
    portfolio.optimize()
